<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title> Argot </title>
</head>

<body>
	<noscript> Argot requires JavaScript to be enabled. </noscript>
	<div id="app_container"></div>

	<script>
		// Hey, I heard you liked single page apps!

		// ====================================================================================
		// We begin by defining a custom UI framework because all the other frameworks have the
		// fatal flaw of not being invented here.
		// ====================================================================================

		// Internals
		const DOM_LAST_STATES = new WeakMap();
		const DOM_EFFECTS = new WeakMap();
		const SENTINEL_MOUNT = Symbol("SENTINEL_MOUNT");
		const SENTINEL_UNMOUNT = Symbol("SENTINEL_UNMOUNT");

		class NodeChildBuilder {
			constructor() {
				this.arr = [];
				this.set = new Set();
			}

			push(child/*: Node*/) {
				this.arr.push(child);
				this.set.add(child);
			}

			apply(container/*: Node*/, write_removed_to) {
				// Remove all missing children.
				for (const child of [...container.childNodes]) {
					if (!this.set.has(child)) {
						child.remove();
						write_removed_to.push(child);
					}
				}

				// Ensure that all children are inserted where they need to be.
				for (let i = this.arr.length - 1; i >= 0; i--) {
					const current = this.arr[i];
					const expected_next = this.arr[i + 1];

					if (current.nextSibling != expected_next || current.parentNode !== container) {
						container.insertBefore(current, expected_next ?? null);
					}
				}
			}
		}

		function getDomKey(t) {
			return t instanceof Element ? t.dataset["key"] : undefined;
		}

		function setDomKey(t, v) {
			t.dataset["key"] = v;
		}

		// Public

		/**
		 * Determine whether a given object is a valid virtual node.
		 */
		function isValidVirtualNode(v) {
			return typeof v === "string" || v instanceof VirtualElement || v instanceof VirtualEffect;
		}

		/**
		 * A virtual element to reconcile into the DOM.
		 */
		class VirtualElement {
			constructor(tag, key, children) {
				console.assert(typeof tag === "string");
				console.assert(typeof key === "string" || key == null);
				console.assert(children instanceof Array && children.every(isValidVirtualNode));

				this.tag = tag.toUpperCase();
				this.key = key;
				this.children = children;
			}
		}

		/**
		 * The base class of all effects in the virtual DOM applying to the DOM.
		*/
		class VirtualEffect {
			constructor() {
				this.new_state = null;
				this.key = this;
			}

			mount(target) { }

			unmount(target) { }

			update(target) { }
		}

		/**
		 * Constructs a virtual DOM element.
		 */
		function tree(tag, key_or_children, children) {
			return children === undefined ?
				new VirtualElement(tag, null, key_or_children.flat()) :
				new VirtualElement(tag, key_or_children, children.flat());
		}

		/**
		 * Applies the specified virtual DOM `tree` to the DOM target.
		 */
		function render(dom/*: Element*/, tree/*: VirtualElement */) /*: void */ {
			console.assert(tree instanceof VirtualElement);

			// Skip rendering if this element is already supposed to look like the provided virtual
			// DOM.
			if (DOM_LAST_STATES.get(dom) === tree) {
				return;
			}
			DOM_LAST_STATES.set(dom, tree);

			// The root `tagName` must never change. Note that, when recursing, we always check the
			// tag name so this indeed only check for root changes.
			console.assert(dom.tagName === tree.tag);

			// Ensure that our element has an entry in the effect map
			let effect_map = DOM_EFFECTS.get(dom);
			if (effect_map == null) {
				effect_map = new Map();
				DOM_EFFECTS.set(dom, effect_map);
			}

			// Mark every existing effect as requiring an unmount
			for (const effect of effect_map.values()) {
				effect.new_state = SENTINEL_UNMOUNT;
			}

			// Collect keyed DOM elements and remove them from their parent.
			const key_map = new Map();

			for (const child of dom.children) {  // Only `Element`s can have keys.
				const child_key = getDomKey(child);
				if (child_key !== undefined) {
					key_map.set(child_key, child);
				}
			}

			// Reconcile the DOM children using our discount version of React's heuristic algorithm.

			// `dom_read_cursor` is a node index, not an element index. Additionally, it may be out of bounds.
			let dom_read_cursor = 0;

			const builder = new NodeChildBuilder();

			for (let tree_cursor = 0; tree_cursor < tree.children.length; tree_cursor += 1) {
				// First, let's determine what needs to be added next.
				const tree_curr = tree.children[tree_cursor];

				// Add effects to the map.
				if (tree_curr instanceof VirtualEffect) {
					const effect_key = tree_curr.key;
					let entry = effect_map.get(effect_key);
					// If this is a novel effect, add it to the old effect map with a mounted state.
					if (entry == null) {
						entry = tree_curr;
						effect_map.set(effect_key, entry);
						tree_curr.new_state = SENTINEL_MOUNT;
					} else {
						// Otherwise, just set its new state.
						entry.new_state = tree_curr;
					}

					continue;
				}

				// If this is a keyed element, we grab it from the key collection
				if (typeof tree_curr !== "string" && tree_curr.key != null) {
					let element = key_map.get(tree_curr.key);

					// If this element didn't exist previously or has changed tag, create it de-novo.
					// In the latter case, we'll delete this element during the cleanup phase so no additional
					// work is required.
					if (element === undefined || element.tagName !== tree_curr.tag) {
						element = document.createElement(tree_curr.tag);

						// Now, render it.
						render(element, tree_curr);

						// ...and set its key.
						setDomKey(element, tree_curr.key);
					} else {
						// Otherwise, remove it from the map to prevent it from being used later.
						key_map.delete(tree_curr.key);

						// Now, render it.
						render(element, tree_curr);
					}

					// Push it to the builder.
					builder.push(element);

					continue;
				}

				// Otherwise, we attempt to update the existing DOM element to match ours.
				let dom_read_curr = dom.childNodes[dom_read_cursor];

				// We skip over keyed elements when doing this determination because keyed elements and regular elements
				// are merged in separately.
				while (dom_read_curr !== undefined && getDomKey(dom_read_curr) !== undefined) {
					dom_read_curr = dom.childNodes[++dom_read_cursor];
				}

				// Attempt to determine which new node should be at this place.
				if (typeof tree_curr === "string") {
					// If we're expecting a string...
					if (!(dom_read_curr instanceof Text)) {
						// And the previous element wasn't a string, create it de-novo.
						dom_read_curr = new Text(tree_curr);
					} else if (dom_read_curr.data !== tree_curr) {
						// Otherwise, update the existing text without updating the `dom_read_curr`.
						dom_read_curr.data = tree_curr;
					}
				} else if (!(dom_read_curr instanceof Element) || dom_read_curr.tagName !== tree_curr.tag.toUpperCase()) {
					// If the current DOM node isn't an Element or its tagName is different, create it de-novo.
					dom_read_curr = document.createElement(tree_curr.tag);
					render(dom_read_curr, tree_curr);
				} else {
					// Both of these objects are elements of the same tag so we can diff them
					// directly.
					render(dom_read_curr, tree_curr);
				}

				// Push the `dom_read_curr` to the builder.
				builder.push(dom_read_curr);

				// Even if we don't end up using the DOM node, we still need to consume it. Note that
				// this may cause `dom_read_cursor` to go out of bounds.
				dom_read_cursor += 1;
			}

			// Now, we just have to apply the builder's layout to the element.
			const removed = []
			builder.apply(dom, removed);

			// Now process the effects.
			for (const child of removed) {
				derender(child);
			}

			// BUG: An order needs to be defined for these such that a) unmount handlers all run
			//  before mount handlers and b) users can predict the order of these handlers.
			for (const [effect_key, effect] of effect_map.entries()) {
				if (effect.new_state === SENTINEL_MOUNT) {
					effect.mount(dom);
				} else if (effect.new_state === SENTINEL_UNMOUNT) {
					effect.unmount(dom);
					effect_map.delete(effect_key);  // Concurrent deletion works well in Map.
				} else {
					effect.update(dom, effect.new_state);
				}
			}
		}

		/**
		 * Strips an entire DOM tree of effects and caches.
		 */
		function derender(dom) {
			// Remove its last state cache
			DOM_LAST_STATES.delete(dom);

			// Clear its effects
			const effects = DOM_EFFECTS.get(dom);

			if (effects !== undefined) {
				DOM_EFFECTS.delete(dom);

				for (const effect of effects.values()) {
					effect.unmount(dom);
				}
			}

			// Recurse into its children
			for (const child of [...dom.childNodes]) {
				derender(child);
			}
		}

		// Extensions
		class ClosureVirtualEffect extends VirtualEffect {
			constructor(key, mount_handler) {
				super();

				this.key = key;
				this.mount_handler = mount_handler;
				this.unmount_handler = null;
			}

			mount(target) {
				this.unmount_handler = this.mount_handler(target);
			}

			unmount(target) {
				if (this.unmount_handler != null) {
					this.unmount_handler(target);
					this.unmount_handler = null;
				}
			}
		}

		class PropVirtualEffect extends VirtualEffect {
			constructor(key, value) {
				super();

				this.key = `prop_${key}`;
				this.prop_key = key;
				this.prop_value = value;
			}

			mount(target) {
				target[this.prop_key] = this.prop_value;
			}

			unmount(target) {
				delete target[this.prop_key];
			}

			update(target, new_value) {
				target[this.prop_key] = new_value.prop_value;
			}
		}

		class HandlerVirtualEffect extends VirtualEffect {
			constructor(key, id, handler) {
				super();

				this.key = key;
				this.id = id;
				this.handler = handler;
			}

			mount(target) {
				target.addEventListener(this.id, this.handler);
			}

			unmount(target) {
				target.removeEventListener(this.id, this.handler);
			}
		}

		class StyleVirtualEffect extends VirtualEffect {
			constructor(key, id, value) {
				super();

				this.key = key;
				this.id = id;
				this.value = value;
			}

			mount(target) {
				target.style.setProperty(this.id, this.value);
			}

			unmount(target) {
				target.style.removeProperty(this.id);
			}

			update(target, new_state) {
				target.style.setProperty(this.id, new_state.value);
			}
		}

		class RefSetEffect extends VirtualEffect {
			constructor(ref) {
				super();
				this.key = "ref_setter";
				this.ref = ref;
			}

			mount(target) {
				this.ref.$ = target;
			}

			unmount(target) {
				this.ref.$ = null;
			}
		}

		class Ref {
			constructor(value) {
				this.$ = value;
			}
		}

		function effect(key, mount_handler) {
			return new ClosureVirtualEffect(`effect_${key}`, mount_handler);
		}

		function prop(key, value) {
			return new PropVirtualEffect(key, value);
		}

		function handler(key, handler) {
			return new HandlerVirtualEffect(`handler_${key}`, key, handler);
		}

		function style(key, value) {
			return new StyleVirtualEffect(`style_${key}`, key, value);
		}

		function setRef(ref) {
			return new RefSetEffect(ref);
		}

		// ====================================================================================
		// To make things efficient, we'll also need a memoization system.
		// ====================================================================================

		// Internal
		const DEPENDENTS = Symbol("DEPENDENTS");
		const VIEW_CACHE = Symbol("VIEW_CACHE");
		const EMPTY_CACHE_SENTINEL = Symbol("EMPTY_CACHE_SENTINEL");

		// Public
		class Component {
			constructor() {
				Component.RENDER_SCOPE = null;

				this[DEPENDENTS] = new Set();
				this[VIEW_CACHE] = EMPTY_CACHE_SENTINEL;
			}

			dirty() {
				const old_deps = this[DEPENDENTS];
				this[DEPENDENTS] = new Set();
				this[VIEW_CACHE] = EMPTY_CACHE_SENTINEL;

				for (const dependent of old_deps) {
					dependent.dirty();
				}
			}

			subscribe() {
				if (Component.RENDER_SCOPE !== null) {
					this[DEPENDENTS].add(Component.RENDER_SCOPE);
				}

				return this;
			}

			renderImmediately() {
				throw "this component cannot be rendered";
			}

			renderCached() {
				// Ensure that people using this view in their view are invalidated when we invalidate
				// ourselves.
				this.subscribe();

				// Recompute a cache if one is not present.
				if (this[VIEW_CACHE] === EMPTY_CACHE_SENTINEL) {
					const parent_scope = Component.RENDER_SCOPE;
					try {
						Component.RENDER_SCOPE = this;
						this[VIEW_CACHE] = this.renderImmediately();
					} finally {
						Component.RENDER_SCOPE = parent_scope;
					}
				}

				return this[VIEW_CACHE];
			}
		}

		// ====================================================================================
		// Now, we can define the application's view components.
		// ====================================================================================

		// Pages
		class AppRoot extends Component {
			constructor() {
				super();
				this.view = "home";
				this.view_comp = new HomePage();
				this.saved_post = new PostState("", "");

				// Courtesy: https://github.com/Gankra/cargo-mommy/blob/0ec17361d8b0573d0155984403e576b788abeb60/responses.json
				this.motd = [
					"*pets your head*",
					"*gives you scritches*",
					"you're such a smart cookie~",
					"that's a good girl~",
					"mommy thinks her little girl earned a big hug~",
					"good girl~\nmommy's so proud of you~",
					"aww, what a good girl~\nmommy knew you could do it~",
					"you did it~!",
					"mommy loves you~",
					"*gives you a sticker*",
					"*boops your nose*",
					"*wraps you in a big hug*",
					"well done~!\nmommy is so happy for you~",
					"what a good girl you are~",
					"that's mommy's clever little girl~",
					"you're doing so well~!",
					"you're making mommy so happy~",
					"mommy loves her cute little girl~",
					"What you have set in motion today will be remembered for aeons to come!",
					"Mommy will see to it that her little girl's name is feared~",
					"Mommy is proud of the evil seed her girl has planted into this accursed world",
				];
				this.motd = this.motd[Math.floor(Math.random() * this.motd.length)];
			}

			setView(id) {
				this.view = id;
				this.view_comp = new {
					"home": HomePage,
					"about": AboutPage,
					"submit": SubmitPage,
				}[id](this);
				this.dirty();
			}

			renderImmediately() {
				return tree("div", [
					effect("configure_webpage", () => {
						document.bgColor = "pink";
					}),
					tree("h1", ["Argot"]),
					tree("marquee", [this.motd]),
					tree("p", [
						tree("button", [
							prop("onclick", () => this.setView("home")),
							style("color", this.view === "home" ? "red" : "inherit"),
							"Home",
						]),
						"\u{202F}",
						tree("button", [
							handler("click", () => this.setView("about")),
							style("color", this.view === "about" ? "red" : "inherit"),
							"About",
						]),
						"\u{202F}",
						tree("button", [
							handler("click", () => this.setView("submit")),
							style("color", this.view === "submit" ? "red" : "inherit"),
							"Submit",
						]),
					]),
					tree("hr", []),
					this.view_comp.renderCached(),
				]);
			}
		}

		class HomePage extends Component {
			constructor() {
				super();
				this.posts = [];
			}

			renderImmediately() {
				return tree("div", []);
			}
		}

		class AboutPage extends Component {
			renderImmediately() {
				return tree("div", [
					tree("p", ["Welcome to Argot! This is a super duper serious link sharing website for intellectuals! Nya~"]),
					tree("img", [prop("src", "https://pbs.twimg.com/media/DT_YODIWkAEKH8X.jpg")]),
					tree("p", ["Ferris The Crab~ This is so nya-tastic!!111"]),
				]);
			}
		}

		class SubmitPage extends Component {
			constructor(app) {
				super();
				this.app = app;
			}

			renderImmediately() {
				const saved_post = this.app.subscribe().saved_post.subscribe();

				return tree("div", "submit_page", [
					tree("h2", ["Submit your link here!"]),
					tree("p", [
						"Title:",
						"\u{202F}",
						tree("input", [
							handler("input", (e) => {
								saved_post.title = e.target.value;
								saved_post.dirty();
							}),
							effect("init", target => {
								target.value = saved_post.title;
							}),
						]),
					]),
					tree("p", [
						"URL:",
						"\u{202F}",
						tree("input", [
							handler("input", (e) => {
								saved_post.url = e.target.value;
								saved_post.dirty();
							}),
							effect("init", target => {
								target.value = saved_post.url;
							}),
						]),
					]),
					tree("button", [
						handler("click", target => {
							console.log("Submitting the stuff!");
							console.log("Name:", saved_post.title);
							console.log("URL:", saved_post.url);
						}),
						"Submit",
					]),
					tree("hr", []),
					RenderPostPreview(
						saved_post.title,
						"You",
						"Now",
						saved_post.url,
						"1",
					),
				]);
			}
		}

		// State
		class PostState extends Component {
			constructor(title, url) {
				super();
				this.title = title;
				this.author = "[not specified]";
				this.time = "[not specified]";
				this.url = url;
				this.id = "[not specified]";
			}
		}

		// Home feed
		function RenderPostPreview(title, author, time, url, id) {
			return tree("div", `post_${id}`, [
				style("border", "1px solid"),
				style("padding", "10px"),
				tree("h2", [title.length > 0 ? title : "No title specified!"]),
				tree("p", ["By ", tree("strong", [author]), ", posted ", tree("strong", [time])]),
				tree("p", [
					url.length > 0 ?
						tree("a", [prop("href", url), url]) :
						tree("span", [style("color", "red"), "No URL specified!"]),
				]),
			]);
		}

		// ====================================================================================
		// Finally, let's start up the application!
		// ====================================================================================

		const ROOT = new AppRoot();

		function tick() {
			requestAnimationFrame(tick);
			render(app_container, ROOT.renderCached());
		}

		requestAnimationFrame(tick);
	</script>
</body>

</html>
