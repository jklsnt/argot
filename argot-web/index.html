<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title> Argot </title>
</head>

<body>
	<noscript> Argot requires JavaScript to be enabled. </noscript>
	<div id="app_container"></div>

	<script>
		// Hey, I heard you liked single page apps!

		// ====================================================================================
		// We begin by defining a custom UI framework because all the other frameworks have the
		// fatal flaw of not being invented here.
		// ====================================================================================

		// Internals
		const DOM_EFFECTS = new WeakMap();
		const SENTINEL_MOUNT = Symbol("SENTINEL_MOUNT");
		const SENTINEL_UNMOUNT = Symbol("SENTINEL_UNMOUNT");

		class NodeChildBuilder {
			constructor() {
				this.arr = [];
				this.set = new Set();
			}

			push(child/*: Node*/) {
				this.arr.push(child);
				this.set.add(child);
			}

			apply(container/*: Node*/) {
				// Remove all missing children.
				for (const child of [...container.childNodes]) {
					if (!this.set.has(child)) {
						child.remove();
					}
				}

				// Ensure that all children are inserted where they need to be.
				for (let i = this.arr.length - 1; i >= 0; i--) {
					const current = this.arr[i];
					const expected_next = this.arr[i + 1];

					if (current.nextSibling != expected_next || current.parentNode !== container) {
						container.insertBefore(current, expected_next ?? null);
					}
				}
			}
		}

		function getDomKey(t) {
			return t.dataset["key"];
		}

		function setDomKey(t, v) {
			t.dataset["key"] = v;
		}

		// Public

		/**
		 * Determine whether a given object is a valid virtual node.
		 */
		function isValidVirtualNode(v) {
			return typeof v === "string" || v instanceof VirtualElement || v instanceof VirtualEffect;
		}

		/**
		 * A virtual element to reconcile into the DOM.
		 */
		class VirtualElement {
			constructor(tag, key, children) {
				console.assert(typeof tag === "string");
				console.assert(typeof key === "string" || key == null);
				console.assert(children instanceof Array && children.every(isValidVirtualNode));

				this.tag = tag.toUpperCase();
				this.key = key;
				this.children = children;
			}
		}

		/**
		 * The base class of all effects in the virtual DOM applying to the DOM.
		*/
		class VirtualEffect {
			constructor() {
				this.new_state = null;
				this.key = this;
			}

			mount(target) { }

			unmount(target) { }

			update(target) { }
		}

		/**
		 * Constructs a virtual DOM element.
		 */
		function tree(tag, key_or_children, children) {
			return children === undefined ?
				new VirtualElement(tag, null, key_or_children.flat()) :
				new VirtualElement(tag, key_or_children, children.flat());
		}

		/**
		 * Applies the specified virtual DOM `tree` to the DOM target.
		 */
		function render(dom/*: Element*/, tree/*: VirtualElement */) /*: void */ {
			console.assert(tree instanceof VirtualElement);

			// The root `tagName` must never change. Note that, when recursing, we always check the
			// tag name so this indeed only check for root changes.
			console.assert(dom.tagName === tree.tag);

			// Ensure that our element has an entry in the effect map
			let effect_map = DOM_EFFECTS.get(dom);
			if (effect_map == null) {
				effect_map = new Map();
				DOM_EFFECTS.set(dom, effect_map);
			}

			// Mark every existing effect as requiring an unmount
			for (const effect of effect_map.values()) {
				effect.new_state = SENTINEL_UNMOUNT;
			}

			// Collect keyed DOM elements and remove them from their parent.
			const key_map = new Map();

			for (const child of dom.children) {  // Only `Element`s can have keys.
				const child_key = getDomKey(child);
				if (child_key !== undefined) {
					key_map.set(child_key, child);
				}
			}

			// Reconcile the DOM children using our discount version of React's heuristic algorithm.

			// `dom_read_cursor` is a node index, not an element index. Additionally, it may be out of bounds.
			let dom_read_cursor = 0;

			const builder = new NodeChildBuilder();

			for (let tree_cursor = 0; tree_cursor < tree.children.length; tree_cursor += 1) {
				// First, let's determine what needs to be added next.
				const tree_curr = tree.children[tree_cursor];

				// Add effects to the map.
				if (tree_curr instanceof VirtualEffect) {
					const effect_key = tree_curr.key;
					let entry = effect_map.get(effect_key);
					// If this is a novel effect, add it to the old effect map with a mounted state.
					if (entry == null) {
						entry = tree_curr;
						effect_map.set(effect_key, entry);
						tree_curr.new_state = SENTINEL_MOUNT;
					} else {
						// Otherwise, just set its new state.
						entry.new_state = tree_curr;
					}

					continue;
				}

				// If this is a keyed element, we grab it from the key collection
				if (typeof tree_curr !== "string" && tree_curr.key != null) {
					let element = key_map.get(tree_curr.key);

					// If this element didn't exist previously or has changed tag, create it de-novo.
					// In the latter case, we'll delete this element during the cleanup phase so no additional
					// work is required.
					if (element === undefined || element.tagName !== tree_curr.tag) {
						element = document.createElement(tree_curr.tag);

						// Now, render it.
						render(element, tree_curr);

						// ...and set its key.
						setDomKey(element, tree_curr.key);
					} else {
						// Otherwise, remove it from the map to prevent it from being used later.
						key_map.delete(tree_curr.key);

						// Now, render it.
						render(element, tree_curr);
					}

					// Push it to the builder.
					builder.push(element);

					continue;
				}

				// Otherwise, we attempt to update the existing DOM element to match ours.
				let dom_read_curr = dom.childNodes[dom_read_cursor];

				// We skip over keyed elements when doing this determination because keyed elements and regular elements
				// are merged in separately.
				while (dom_read_curr !== undefined && dom_read_curr.key !== undefined) {
					dom_read_curr = dom.childNodes[++dom_read_cursor];
				}

				// Attempt to determine which new node should be at this place.
				if (typeof tree_curr === "string") {
					// If we're expecting a string...
					if (!(dom_read_curr instanceof Text)) {
						// And the previous element wasn't a string, create it de-novo.
						dom_read_curr = new Text(tree_curr);
					} else if (dom_read_curr.data !== tree_curr) {
						// Otherwise, update the existing text without updating the `dom_read_curr`.
						dom_read_curr.data = tree_curr;
					}
				} else if (!(dom_read_curr instanceof Element) || dom_read_curr.tagName !== tree_curr.tag.toUpperCase()) {
					// If the current DOM node isn't an Element or its tagName is different, create it de-novo.
					dom_read_curr = document.createElement(tree_curr.tag);
					render(dom_read_curr, tree_curr);
				} else {
					// Both of these objects are elements of the same tag so we can diff them
					// directly.
					render(dom_read_curr, tree_curr);
				}

				// Push the `dom_read_curr` to the builder.
				builder.push(dom_read_curr);

				// Even if we don't end up using the DOM node, we still need to consume it. Note that
				// this may cause `dom_read_cursor` to go out of bounds.
				dom_read_cursor += 1;
			}

			// Now, we just have to apply the builder's layout to the element.
			builder.apply(dom);

			// Now process the effects.
			for (const [effect_key, effect] of effect_map.entries()) {
				if (effect.new_state === SENTINEL_MOUNT) {
					effect.mount(dom);
				} else if (effect.new_state === SENTINEL_UNMOUNT) {
					effect.unmount(dom);
					effect_map.delete(effect_key);  // Concurrent deletion works well in Map.
				} else {
					effect.update(dom, effect.new_state);
				}
			}
		}

		// Extensions
		class ClosureVirtualEffect extends VirtualEffect {
			constructor(key, mount_handler) {
				super();

				this.key = key;
				this.mount_handler = mount_handler;
				this.unmount_handler = null;
			}

			mount(target) {
				this.unmount_handler = this.mount_handler(target);
			}

			unmount(target) {
				if (this.unmount_handler != null) {
					this.unmount_handler(target);
					this.unmount_handler = null;
				}
			}
		}

		class PropVirtualEffect extends VirtualEffect {
			constructor(key, value) {
				super();

				this.key = `prop_${key}`;
				this.prop_key = key;
				this.prop_value = value;
			}

			mount(target) {
				target[this.prop_key] = this.prop_value;
			}

			unmount(target) {
				delete target[this.prop_key];
			}

			update(target, new_value) {
				target[this.prop_key] = new_value.prop_value;
			}
		}

		class HandlerVirtualEffect extends VirtualEffect {
			constructor(key, id, handler) {
				super();

				this.key = key;
				this.id = id;
				this.handler = handler;
			}

			mount(target) {
				target.addEventListener(this.id, this.handler);
			}

			unmount(target) {
				target.removeEventListener(this.id, this.handler);
			}
		}

		class StyleVirtualEffect extends VirtualEffect {
			constructor(key, id, value) {
				super();

				this.key = key;
				this.id = id;
				this.value = value;
			}

			mount(target) {
				target.style.setProperty(this.id, this.value);
			}

			unmount(target) {
				target.style.removeProperty(this.id);
			}

			update(target, new_state) {
				target.style.setProperty(this.id, new_state.value);
			}
		}

		function effect(key, mount_handler) {
			return new ClosureVirtualEffect(`effect_${key}`, mount_handler);
		}

		function prop(key, value) {
			return new PropVirtualEffect(key, value);
		}

		function handler(key, handler) {
			return new HandlerVirtualEffect(`handler_${key}`, key, handler);
		}

		function style(key, value) {
			return new StyleVirtualEffect(`style_${key}`, key, value);
		}

		// ====================================================================================
		// Our custom UI framework requires a separation between model and view+controller so
		// we define our model here.
		// ====================================================================================

		class AppRoot {
			constructor() {
				this.view = "home";
			}
		}

		// ====================================================================================
		// Now, we can define the application's view components.
		// ====================================================================================

		function AppRootView(state) {
			return tree("div", [
				effect("configure_webpage", () => {
					document.bgColor = "pink";
				}),
				tree("h1", ["Argot"]),
				tree("p", [
					tree("button", [
						prop("onclick", () => (state.view = "home")),
						style("color", state.view === "home" ? "red" : "inherit"),
						"Home",
					]),
					"\u{202F}",
					tree("button", [
						handler("click", () => (state.view = "about")),
						style("color", state.view === "about" ? "red" : "inherit"),
						"About",
					]),
					"\u{202F}",
					tree("button", [
						handler("click", () => (state.view = "submit")),
						style("color", state.view === "submit" ? "red" : "inherit"),
						"Submit",
					]),
				]),
				tree("hr", []),
				{
					"home": HomeView,
					"about": AboutView,
					"submit": SubmitView,
				}
				[state.view](state),
			]);
		}

		function HomeView(state) {
			return tree("div", []);
		}

		function AboutView(state) {
			return tree("div", [
				tree("p", ["Welcome to Argot! This is a super duper serious link sharing website for intellectuals! Nya~"]),
				tree("img", [prop("src", "https://pbs.twimg.com/media/DT_YODIWkAEKH8X.jpg")]),
				tree("p", ["Ferris The Crab~ This is so nya-tastic!!111"]),
			]);
		}

		function SubmitView(state) {
			return tree("div", "submit_view", [
				effect("whee", (target) => {
					console.log("Mounted", target);
					return target => console.log("Unmounted", target);
				}),
				tree("h2", ["Submit your link here!"]),
				tree("p", [
					"Name:",
					"\u{202F}",
					tree("input", []),
				]),
				tree("p", [
					"URL:",
					"\u{202F}",
					tree("input", []),
				]),
				tree("button", [
					handler("click", () => {
						console.log("Submitting the stuff!");
					}),
					"Submit",
				]),
			]);
		}

		// ====================================================================================
		// Finally, let's start up the application!
		// ====================================================================================

		const APP_STATE = new AppRoot();

		function tick() {
			requestAnimationFrame(tick);
			render(app_container, AppRootView(APP_STATE));
		}

		requestAnimationFrame(tick);
	</script>
</body>

</html>
