<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title> Argot </title>
</head>

<body>
	<noscript> Argot requires JavaScript to be enabled. </noscript>
	<div id="app_container"></div>

	<script>
		// Hey, I heard you liked single page apps!

		// ====================================================================================
		// We begin by defining a custom UI framework because all the other frameworks have the
		// fatal flaw of not being invented here.
		//
		// General architecture:
		//
		// - This module handles the ability to reconcile a virtual DOM with the physical DOM
		//   and exposes an API for writing effectful hooks.
		// - The second module handles the ability to cache virtual DOMs and update them only
		//   on state change as well as the ability to map state to derived state in a
		//   memoization-friendly way.
		//
		// ====================================================================================

		// Internals
		const DOM_LAST_STATES = new WeakMap();
		const DOM_EFFECTS = new WeakMap();
		const SENTINEL_MOUNT = Symbol("SENTINEL_MOUNT");
		const SENTINEL_UNMOUNT = Symbol("SENTINEL_UNMOUNT");

		class NodeChildBuilder {
			constructor() {
				this.arr = [];
				this.set = new Set();
			}

			push(child/*: Node*/) {
				this.arr.push(child);
				this.set.add(child);
			}

			apply(container/*: Node*/, write_removed_to) {
				// Remove all missing children.
				for (const child of [...container.childNodes]) {
					if (!this.set.has(child)) {
						child.remove();
						write_removed_to.push(child);
					}
				}

				// Ensure that all children are inserted where they need to be.
				for (let i = this.arr.length - 1; i >= 0; i--) {
					const current = this.arr[i];
					const expected_next = this.arr[i + 1];

					if (current.nextSibling != expected_next || current.parentNode !== container) {
						container.insertBefore(current, expected_next ?? null);
					}
				}
			}
		}

		function getDomKey(t) {
			return t instanceof Element ? t.dataset["key"] : undefined;
		}

		function setDomKey(t, v) {
			t.dataset["key"] = v;
		}

		// Public

		/**
		 * Determine whether a given object is a valid virtual node.
		 */
		function isValidVirtualNode(v) {
			return typeof v === "string" || v instanceof VirtualElement || v instanceof VirtualEffect;
		}

		/**
		 * A virtual element to reconcile into the DOM.
		 */
		class VirtualElement {
			constructor(tag, key, children) {
				console.assert(typeof tag === "string");
				console.assert(typeof key === "string" || key == null);
				console.assert(children instanceof Array && children.every(isValidVirtualNode));

				this.tag = tag.toUpperCase();
				this.key = key;
				this.children = children;
			}
		}

		/**
		 * The base class of all effects in the virtual DOM applying to the DOM.
		*/
		class VirtualEffect {
			constructor() {
				this.new_state = null;
				this.key = this;
			}

			mount(target) { }

			unmount(target) { }

			update(target) { }
		}

		/**
		 * Constructs a virtual DOM element.
		 */
		function elem(tag, key_or_children, children) {
			return children === undefined ?
				new VirtualElement(tag, null, key_or_children.flat()) :
				new VirtualElement(tag, key_or_children, children.flat());
		}

		/**
		 * Applies the specified virtual DOM `tree` to the DOM target.
		 */
		function render(dom/*: Element*/, tree/*: VirtualElement */) /*: void */ {
			console.assert(tree instanceof VirtualElement);

			// Skip rendering if this element is already supposed to look like the provided virtual
			// DOM.
			if (DOM_LAST_STATES.get(dom) === tree) {
				return;
			}
			DOM_LAST_STATES.set(dom, tree);

			// The root `tagName` must never change. Note that, when recursing, we always check the
			// tag name so this indeed only check for root changes.
			console.assert(dom.tagName === tree.tag);

			// Ensure that our element has an entry in the effect map
			let effect_map = DOM_EFFECTS.get(dom);
			if (effect_map == null) {
				effect_map = new Map();
				DOM_EFFECTS.set(dom, effect_map);
			}

			// Mark every existing effect as requiring an unmount
			for (const effect of effect_map.values()) {
				effect.new_state = SENTINEL_UNMOUNT;
			}

			// Collect keyed DOM elements and remove them from their parent.
			const key_map = new Map();

			for (const child of dom.children) {  // Only `Element`s can have keys.
				const child_key = getDomKey(child);
				if (child_key !== undefined) {
					key_map.set(child_key, child);
				}
			}

			// Reconcile the DOM children using our discount version of React's heuristic algorithm.

			// `dom_read_cursor` is a node index, not an element index. Additionally, it may be out of bounds.
			let dom_read_cursor = 0;

			const builder = new NodeChildBuilder();

			for (let tree_cursor = 0; tree_cursor < tree.children.length; tree_cursor += 1) {
				// First, let's determine what needs to be added next.
				const tree_curr = tree.children[tree_cursor];

				// Add effects to the map.
				if (tree_curr instanceof VirtualEffect) {
					const effect_key = tree_curr.key;
					let entry = effect_map.get(effect_key);
					// If this is a novel effect, add it to the old effect map with a mounted state.
					if (entry == null) {
						entry = tree_curr;
						effect_map.set(effect_key, entry);
						tree_curr.new_state = SENTINEL_MOUNT;
					} else {
						// Otherwise, just set its new state.
						entry.new_state = tree_curr;
					}

					continue;
				}

				// If this is a keyed element, we grab it from the key collection
				if (typeof tree_curr !== "string" && tree_curr.key != null) {
					let element = key_map.get(tree_curr.key);

					// If this element didn't exist previously or has changed tag, create it de-novo.
					// In the latter case, we'll delete this element during the cleanup phase so no additional
					// work is required.
					if (element === undefined || element.tagName !== tree_curr.tag) {
						element = document.createElement(tree_curr.tag);

						// Now, render it.
						render(element, tree_curr);

						// ...and set its key.
						setDomKey(element, tree_curr.key);
					} else {
						// Otherwise, remove it from the map to prevent it from being used later.
						key_map.delete(tree_curr.key);

						// Now, render it.
						render(element, tree_curr);
					}

					// Push it to the builder.
					builder.push(element);

					continue;
				}

				// Otherwise, we attempt to update the existing DOM element to match ours.
				let dom_read_curr = dom.childNodes[dom_read_cursor];

				// We skip over keyed elements when doing this determination because keyed elements and regular elements
				// are merged in separately.
				while (dom_read_curr !== undefined && getDomKey(dom_read_curr) !== undefined) {
					dom_read_curr = dom.childNodes[++dom_read_cursor];
				}

				// Attempt to determine which new node should be at this place.
				if (typeof tree_curr === "string") {
					// If we're expecting a string...
					if (!(dom_read_curr instanceof Text)) {
						// And the previous element wasn't a string, create it de-novo.
						dom_read_curr = new Text(tree_curr);
					} else if (dom_read_curr.data !== tree_curr) {
						// Otherwise, update the existing text without updating the `dom_read_curr`.
						dom_read_curr.data = tree_curr;
					}
				} else if (!(dom_read_curr instanceof Element) || dom_read_curr.tagName !== tree_curr.tag.toUpperCase()) {
					// If the current DOM node isn't an Element or its tagName is different, create it de-novo.
					dom_read_curr = document.createElement(tree_curr.tag);
					render(dom_read_curr, tree_curr);
				} else {
					// Both of these objects are elements of the same tag so we can diff them
					// directly.
					render(dom_read_curr, tree_curr);
				}

				// Push the `dom_read_curr` to the builder.
				builder.push(dom_read_curr);

				// Even if we don't end up using the DOM node, we still need to consume it. Note that
				// this may cause `dom_read_cursor` to go out of bounds.
				dom_read_cursor += 1;
			}

			// Now, we just have to apply the builder's layout to the element.
			const removed = []
			builder.apply(dom, removed);

			// Now process the effects.
			for (const child of removed) {
				derender(child);
			}

			// BUG: An order needs to be defined for these such that a) unmount handlers all run
			//  before mount handlers and b) users can predict the order of these handlers.
			for (const [effect_key, effect] of effect_map.entries()) {
				if (effect.new_state === SENTINEL_MOUNT) {
					effect.mount(dom);
				} else if (effect.new_state === SENTINEL_UNMOUNT) {
					effect.unmount(dom);
					effect_map.delete(effect_key);  // Concurrent deletion works well in Map.
				} else {
					effect.update(dom, effect.new_state);
				}
			}
		}

		/**
		 * Strips an entire DOM tree of effects and caches.
		 */
		function derender(dom) {
			// Remove its last state cache
			DOM_LAST_STATES.delete(dom);

			// Clear its effects
			const effects = DOM_EFFECTS.get(dom);

			if (effects !== undefined) {
				DOM_EFFECTS.delete(dom);

				for (const effect of effects.values()) {
					effect.unmount(dom);
				}
			}

			// Recurse into its children
			for (const child of [...dom.childNodes]) {
				derender(child);
			}
		}

		// Extensions
		class ClosureVirtualEffect extends VirtualEffect {
			constructor(key, mount_handler) {
				super();

				this.key = key;
				this.mount_handler = mount_handler;
				this.unmount_handler = null;
			}

			mount(target) {
				this.unmount_handler = this.mount_handler(target);
			}

			unmount(target) {
				if (this.unmount_handler != null) {
					this.unmount_handler(target);
					this.unmount_handler = null;
				}
			}
		}

		class PropVirtualEffect extends VirtualEffect {
			constructor(key, value) {
				super();

				this.key = `prop_${key}`;
				this.prop_key = key;
				this.prop_value = value;
			}

			mount(target) {
				target[this.prop_key] = this.prop_value;
			}

			unmount(target) {
				delete target[this.prop_key];
			}

			update(target, new_value) {
				target[this.prop_key] = new_value.prop_value;
			}
		}

		class HandlerVirtualEffect extends VirtualEffect {
			constructor(key, id, handler) {
				super();

				this.key = key;
				this.id = id;
				this.handler = handler;
			}

			mount(target) {
				target.addEventListener(this.id, this.handler);
			}

			unmount(target) {
				target.removeEventListener(this.id, this.handler);
			}
		}

		class StyleVirtualEffect extends VirtualEffect {
			constructor(key, id, value) {
				super();

				this.key = key;
				this.id = id;
				this.value = value;
			}

			mount(target) {
				target.style.setProperty(this.id, this.value);
			}

			unmount(target) {
				target.style.removeProperty(this.id);
			}

			update(target, new_state) {
				target.style.setProperty(this.id, new_state.value);
			}
		}

		class RefSetEffect extends VirtualEffect {
			constructor(ref) {
				super();
				this.key = "ref_setter";
				this.ref = ref;
			}

			mount(target) {
				this.ref.$ = target;
			}

			unmount(target) {
				this.ref.$ = null;
			}
		}

		class Ref {
			constructor(value) {
				this.$ = value;
			}
		}

		function effect(key, mount_handler) {
			return new ClosureVirtualEffect(`effect_${key}`, mount_handler);
		}

		function prop(key, value) {
			return new PropVirtualEffect(key, value);
		}

		function handler(key, handler) {
			return new HandlerVirtualEffect(`handler_${key}`, key, handler);
		}

		function style(key, value) {
			return new StyleVirtualEffect(`style_${key}`, key, value);
		}

		function setRef(ref) {
			return new RefSetEffect(ref);
		}

		// ====================================================================================
		// To make things efficient, we'll also need a memoization system.
		// ====================================================================================

		// Internal
		const DEPENDENTS = Symbol("DEPENDENTS");
		const VIEW_CACHE = Symbol("VIEW_CACHE");
		const DERIVED_MAP = Symbol("DERIVED_MAP");
		const EMPTY_CACHE_SENTINEL = Symbol("EMPTY_CACHE_SENTINEL");
		const IS_RENDERING = Symbol("IS_RENDERING");

		let RENDER_SCOPE = null;

		// Public
		class Component {
			constructor() {
				this[DEPENDENTS] = new Set();
				this[VIEW_CACHE] = EMPTY_CACHE_SENTINEL;
				this[DERIVED_MAP] = new Map();
				this[IS_RENDERING] = false;
			}

			deriveChild(namespace, key, ctor) {
				let store = this[DERIVED_MAP].get(namespace);
				if (store === undefined) {
					store = new DerivedComponentMap();
					this[DERIVED_MAP].set(namespace, store);
				}

				return store.fetch(key, ctor !== undefined ? ctor : () => new namespace());
			}

			renderChild(namespace, key, effects, ctor) {
				const child = this.deriveChild(namespace, key, ctor);
				if (effects !== undefined) {
					if (typeof effects === "function") {
						effects(child);
					} else if (typeof effects === "object") {
						for (const key of Object.keys(effects)) {
							child.dirtySet(key, effects[key]);
						}
					} else {
						console.assert(false);
					}
				}
				return child.render();
			}

			dirty() {
				// If we're actively being rendered, it is dangerous to clear the dependents list
				// since, once `render` finishes, it'll set the cache without full knowledge of the
				// dependent list. It is, however, safe to just ignore this entire node during the
				// dirty DFS since the fact that we're actively rendering tells us that the previous
				// dependency list was already processed.
				if (this[IS_RENDERING]) {
					return;
				}

				const old_deps = this[DEPENDENTS];
				this[DEPENDENTS] = new Set();
				this[VIEW_CACHE] = EMPTY_CACHE_SENTINEL;

				for (const dependent of old_deps) {
					dependent.dirty();
				}
			}

			dirtySet(key, value) {
				if (this[key] !== value) {
					this[key] = value;
					this.dirty();
				}
			}

			subscribe() {
				if (RENDER_SCOPE !== null) {
					this[DEPENDENTS].add(RENDER_SCOPE);
				}

				return this;
			}

			doRender() {
				throw "this component cannot be rendered";
			}

			render() {
				// Render is not reentrant.
				console.assert(!this[IS_RENDERING]);

				// Ensure that people using this view in their view are invalidated when we invalidate
				// ourselves.
				this.subscribe();

				// Recompute a cache if one is not present.
				if (this[VIEW_CACHE] === EMPTY_CACHE_SENTINEL) {
					// Reset the derivation stores
					for (const store of this[DERIVED_MAP].values()) {
						store.begin();
					}

					// Render it
					const parent_scope = RENDER_SCOPE;
					try {
						this[IS_RENDERING] = true;
						RENDER_SCOPE = this;
						this[VIEW_CACHE] = this.doRender();
					} finally {
						this[IS_RENDERING] = false;
						RENDER_SCOPE = parent_scope;
					}
				}

				return this[VIEW_CACHE];
			}
		}

		class DerivedComponentMap {
			constructor() {
				this.persistent_cache = new Map();
				this.to_delete = new Set();
				this.auto_key_counter = 0;
			}

			begin() {
				for (const to_delete of this.to_delete) {
					this.persistent_cache.delete(to_delete);
				}
				this.to_delete = new Set(this.persistent_cache.keys());
				this.auto_key_counter = 0;
			}

			fetch(key, ctor) {
				if (key == null) {
					key = `auto_${this.auto_key_counter++}`;
				}

				this.to_delete.delete(key);
				let value = this.persistent_cache.get(key);
				if (value === undefined) {
					value = ctor();
					this.persistent_cache.set(key, value);
				}

				return value;
			}
		}

		// Short forms
		class InlineComponent extends Component {
			constructor(renderer) {
				super();
				this.renderer = renderer;
			}

			doRender() {
				return this.renderer(this);
			}
		}

		// ====================================================================================
		// Now, we can define the application's model.
		// ====================================================================================

		class PostListState extends Component {
			constructor() {
				super();
				this.posts = [new PostState("post_0", "Look at this cool website!", "http://www.example.com")];
			}
		}

		class PostState extends Component {
			constructor(id, title, url) {
				super();
				this.id = id;
				this.title = title;
				this.url = url;
				this.author = "[not specified]";
				this.time = "[not specified]";

				this.is_url_valid = new InlineComponent(() => {
					try {
						const url = new URL(this.subscribe().url);
						return url.protocol === "http:" || url.protocol === "https:";
					} catch (e) {
						return false;
					}
				});
			}
		}

		// ====================================================================================
		// ...as well as the app's view components.
		// ====================================================================================

		// Pages
		class AppRoot extends Component {
			constructor() {
				super();
				this.view = "home";
				this.view_comp = new HomePage(this);

				this.saved_post = new PostState("saved_post", "", "");
				this.fetched_posts = new PostListState();

				this.username = "Anonymous";
			}

			setView(id) {
				this.view = id;
				this.view_comp = new {
					"home": HomePage,
					"about": AboutPage,
					"submit": SubmitPage,
				}[id](this);
				this.dirty();
			}

			doRender() {
				const { username } = this;

				// Bind the author to the saved post.
				this.saved_post.dirtySet("author", username);

				return elem("div", [
					effect("configure_webpage", () => {
						document.bgColor = "pink";
					}),
					elem("h1", ["Argot"]),
					elem("p", [
						elem("button", [
							prop("onclick", () => this.setView("home")),
							style("color", this.view === "home" ? "red" : "inherit"),
							"Home",
						]),
						"\u{202F}",
						elem("button", [
							handler("click", () => this.setView("about")),
							style("color", this.view === "about" ? "red" : "inherit"),
							"About",
						]),
						"\u{202F}",
						elem("button", [
							handler("click", () => this.setView("submit")),
							style("color", this.view === "submit" ? "red" : "inherit"),
							"Submit",
						]),
						"\u{202F}",
						elem("button", [
							handler("click", () => {
								this.username = `user ${Math.floor(Math.random() * 100)}`;
								this.dirty();
							}),
							"Fake Login Button",
						]),
						elem("strong", [" - ", username.toUpperCase()]),
					]),
					elem("hr", []),
					this.view_comp.render(),
				]);
			}
		}

		class HomePage extends Component {
			constructor(app) {
				super();
				this.app = app;
			}

			doRender() {
				const post_list = this.app.fetched_posts.subscribe().posts;

				return elem("div", [
					post_list.map(state => this.renderChild(
						PostPreviewView,
						state.id,
						() => { },
						() => new PostPreviewView(state),
					)),
				]);
			}
		}

		class AboutPage extends Component {
			doRender() {
				return elem("div", [
					elem("p", ["Welcome to Argot! This is a super duper serious link sharing website for intellectuals! Nya~"]),
					elem("img", [prop("src", "https://pbs.twimg.com/media/DT_YODIWkAEKH8X.jpg")]),
					elem("p", ["Ferris The Crab~ This is so nya-tastic!!111"]),
				]);
			}
		}

		class SubmitPage extends Component {
			constructor(app) {
				super();
				this.app = app;
			}

			doRender() {
				const { saved_post, fetched_posts } = this.app;
				saved_post.subscribe();

				return elem("div", "submit_page", [
					elem("h2", ["Submit your link here!"]),
					elem("p", [
						"Title:",
						"\u{202F}",
						elem("input", [
							handler("input", (e) => {
								saved_post.title = e.target.value;
								saved_post.dirty();
							}),
							prop("value", saved_post.title),
						]),
					]),
					elem("p", [
						"URL:",
						"\u{202F}",
						elem("input", [
							handler("input", (e) => {
								saved_post.url = e.target.value;
								saved_post.dirty();
							}),
							prop("value", saved_post.url),
						]),
					]),
					elem("button", [
						handler("click", target => {
							// Create the post
							const post = new PostState(
								`post_${this.app.fetched_posts.posts.length}`,
								saved_post.title,
								saved_post.url,
							);
							post.author = this.app.username;
							fetched_posts.posts.push(post);
							fetched_posts.dirty();

							// Clear the saved post
							saved_post.title = "";
							saved_post.url = "";
							saved_post.dirty();
						}),
						"Submit",
					]),
					elem("hr", []),
					this.renderChild(PostPreviewView, "preview", post => post.dirtySet("state", saved_post)),
				]);
			}
		}

		// Home feed
		class PostPreviewView extends Component {
			constructor(state) {
				super();
				this.state = state;
			}

			doRender() {
				const { title, author, time, url, id, is_url_valid } = this.state.subscribe();

				return elem("div", `post_preview_for_${id}`, [
					style("border", "1px solid"),
					style("padding", "10px"),
					elem("h2", [title.length > 0 ? title : "No title specified!"]),
					elem("p", ["By ", elem("strong", [author]), ", posted ", elem("strong", [time])]),
					elem("p", [
						url.length > 0 ?
							(is_url_valid.render() ?
								elem("a", [prop("href", url), url]) :
								elem("span", [
									elem("span", [style("color", "gray"), url]),
									elem("span", [style("color", "red"), " - This URL is not valid"])
								])
							) :
							elem("span", [style("color", "red"), "No URL specified!"]),
					]),
					this.renderChild(FunkyText, null, { text: url }),
					this.renderChild(FunkyText, null, { text: url }),
				]);
			}
		}

		class FunkyText extends Component {
			constructor(text) {
				super();
				this.text = "";
			}

			doRender() {
				return elem("h1", [style("color", "red"), this.text]);
			}
		}

		// ====================================================================================
		// Finally, let's start up the application!
		// ====================================================================================

		const ROOT = new AppRoot();

		function tick() {
			requestAnimationFrame(tick);
			render(app_container, ROOT.render());
		}

		requestAnimationFrame(tick);
	</script>
</body>

</html>
